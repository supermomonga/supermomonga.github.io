<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2014-02-01T15:00:00Z</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>momonga.vim #2.2 進捗のVimmer</title>
    <link rel="alternate" href="http://blog.url.com/articles/vim/momongavim-2_2.html"/>
    <id>http://blog.url.com/articles/vim/momongavim-2_2.html</id>
    <published>2014-02-01T15:00:00Z</published>
    <updated>2014-02-02T17:01:56+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2 id="toc_0"&gt;momonga.vim #2.2 に参加しました&lt;/h2&gt;

&lt;p&gt;momonga.vim #2.2 に参加してきましたので、レポート記事を投稿したいと思います。&lt;/p&gt;

&lt;p&gt;momonga.vim #2.2 は、#2 開催から時間が経ったものの、会場の予約の都合上#3まで時間が空きすぎて、Vimもくもく会成分が欠如して生活に支障が出そうということで企画された少人数のvimもくもく会です。小数点付きの回は大体このような少人数もくもく会を指します。&lt;/p&gt;

&lt;h2 id="toc_1"&gt;集合&lt;/h2&gt;

&lt;p&gt;12:20頃、ももんがさんの家に集合しました。私はももんがさんなのでももんがさんの家までは徒歩0分の距離であり、労せず到着することができました。&lt;/p&gt;

&lt;p&gt;参加者は私を含めて以下の5人です。前回の #2.1 も同じメンツでした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;@deris0126 （derisさん）&lt;/li&gt;
&lt;li&gt;@Linda_pp （りんだんさん）&lt;/li&gt;
&lt;li&gt;@rbtnn （rbtnnさん）&lt;/li&gt;
&lt;li&gt;@thinca （thincaさん）&lt;/li&gt;
&lt;li&gt;@supermomonga （ももんがさん）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="toc_2"&gt;昼食&lt;/h2&gt;

&lt;p&gt;集まったので昼食です。最近糖質制限をしているのですが、誰かと一緒にごはんを食べるときは制限しないという例外を敷いているので、thincaさんの希望もありラーメンになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/uploads/2014-02-01-lunch.jpg" class="full" /&gt;&lt;/p&gt;

&lt;h2 id="toc_3"&gt;もくもく会&lt;/h2&gt;

&lt;p&gt;もくもくしました。だいぶもくもくしたので煙がすごいでたと思います。&lt;/p&gt;

&lt;p&gt;VCS.vim、puyo.vimにぷよテト実装、オプションパーサ、Sidecar、duzzleアップデート、みたいによくわからないけど各々の心にプレッシャーが発生する呪文を各自が唱え合ってた気がします。&lt;/p&gt;

&lt;p&gt;私の場合、その成果として、ThingsPast.vimへのシンタックスや各種Hook追加を行い大々的にリファクタリングしたメジャーバージョンアップ版のリリースや長らく構成を決めかねていたSidecar.vimの正式版リリースに加えて放置されているFAX Advent Calendar 2013のネタプラギンを颯爽と完成させものすごい進捗を叩きだしたということは一切なくてvimrcを整理して小さいプラギンを新しく1つ作っただけでした。このプラギンは&lt;a href="https://github.com/supermomonga/projectlocal.vim"&gt;projectlocal.vim&lt;/a&gt;というもので、近日中に解説記事を書きます。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/uploads/2014-02-01-mokumoku.jpg" class="full" /&gt;&lt;/p&gt;

&lt;p&gt;お菓子よかった。&lt;/p&gt;

&lt;h2 id="toc_4"&gt;夕食&lt;/h2&gt;

&lt;p&gt;20時頃。中華料理屋さん行きました。私はレバ野菜炒めと餃子。900円。
derisさんとthincaさんはお昼にラーメン食べたのにまた麺類を食べていました。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/uploads/2014-02-01-dinner.jpg" class="full" /&gt;&lt;/p&gt;

&lt;p&gt;ここで翌日予定のあるderisさんとはお別れしました。お疲れ様でした。&lt;/p&gt;

&lt;h2 id="toc_5"&gt;vimrc読書会に参加&lt;/h2&gt;

&lt;p&gt;毎週土曜日の23時からオンラインのチャットルームで開催されているvimrc読書会が始まりました。せっかくなので、みんなで参加します。というか、今回読まれたのは私のvimrcでした。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://vim-jp.org/reading-vimrc/archive/083.html"&gt;第83回 vimrc読書会&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="toc_6"&gt;徹夜もくもく会&lt;/h2&gt;

&lt;p&gt;徹夜でもくもく会をして、みんなでものすごい進捗を出しました。私は、アイマスクをつけて横たわり毛布を纏うという姿勢で、今後もっと日本のVimシーンを盛り上げていくにはどうすればよいのかについて、とても真剣に瞑想を行っていました。朝まで。なので寝ていたわけではないです。&lt;/p&gt;

&lt;h2 id="toc_7"&gt;朝&lt;/h2&gt;

&lt;p&gt;&lt;img src="/images/uploads/2014-02-02-morning.jpg" class="full" /&gt;&lt;/p&gt;

&lt;p&gt;朝モスしました。&lt;/p&gt;

&lt;p&gt;その後ちょっともくもくしたようなしなかったような感じで、昼前に解散しました。&lt;/p&gt;

&lt;h2 id="toc_8"&gt;まとめ&lt;/h2&gt;

&lt;p&gt;最近私事によりかなり忙しく、Vim活ができていなかったので、かなりよい休日を過ごすことができました。参加者の皆さんありがとうございます。&lt;/p&gt;

&lt;p&gt;momonga.vim #2.2 に来てくださった他のみなさんも、参加レポート記事を書いてくれると思うので、期待しています。&lt;/p&gt;

&lt;p&gt;来月、3月には最大20人規模の&lt;a href="http://partake.in/events/52a7b249-5183-4f1a-9e4f-22c1f0e436a5"&gt;momonga.vim #3&lt;/a&gt;が開催予定なので、Vimに関して一日中もくもくしてみたい方は、よろしければご参加ください。&lt;/p&gt;

&lt;h2 id="toc_9"&gt;おわり&lt;/h2&gt;

&lt;p&gt;おわり&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>人間のよさについて</title>
    <link rel="alternate" href="http://blog.url.com/articles/others/hai.html"/>
    <id>http://blog.url.com/articles/others/hai.html</id>
    <published>2014-02-01T15:00:00Z</published>
    <updated>2014-02-02T21:57:17+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;おれはじぶんの「嫌いだ」といふ印象を信用しないことにしてゐる。その「嫌いだ」といふのは、たいていは相手の一部だけについて感じたり言ったりしてゐるので、相手の全人格のほうへ関心をのばせば考慮や納得のする根拠があるのがほとんどだ。さういふただ部分についてだけで「嫌いだ」といふ判断をするのは、間違ってゐるとおもふ。そんな判断の仕方は無くなるのが理想だとおもってゐる。常不軽菩薩のやうな超人になれといふのは言ひ過ぎで、「嫌い」なのは「嫌い」でいいんだ。だがそれには、全人格と全現在をかんがへなければならない。それを放棄したときにおれは死ぬ。ひとつずつ進んでゆくしかないのだとおもふ。
&lt;cite&gt;&lt;a href="http://c4se.hatenablog.com/entry/2014/02/02/081234"&gt;http://c4se.hatenablog.com/entry/2014/02/02/081234&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- --&gt;

&lt;blockquote&gt;
&lt;p&gt;私は、自分のことを省みてみろ、自分の子供だったころのことを考えてみろよ、という事で尽きますし、あとは吉本隆明さんが言っているのに付け加えることもないので、黙っています。
&lt;cite&gt;&lt;a href="http://c4se.hatenablog.com/entry/2012/07/05/200405"&gt;http://c4se.hatenablog.com/entry/2012/07/05/200405&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この点について私は恐らく、概ね同じような考えを持っていて、誰かと接する時、その相手が過去に何をやったであるとか、どういう欠点があるのだとか、そういった事柄で相手の人格を判断しないように、極力している。欠点があることや間違いを犯すのはあたりまえのことで、その点だけで相手を判断して交流を行う、もしくは行わないということをやっていると、なにか人間の「よさ」のようなものに対する感度が次第に鈍っていってしまう様に思える。そんな考えに至るのは自分の欠点に対する免罪符であると言われてしまえば完全には否定できない。そうかもしれない、と思う。でも、とにかくこの考え方が私にはしっくりくるし、合っているのだと思う。&lt;/p&gt;

&lt;p&gt;これは私の生き方の指針であり自分の中で完結している問題であるので他人は関係なく、また広く同意を得られる様な考え方ではないと思っている。なので、私がこういった考え方をしているということを誰かに言ったり、文章にしたりすることはなかった。ところが、意外に身近な所からこういった文章が出てきたので、そういった価値観の人も少なくはないのかもしれない、と思い、つい文章にしてしまった。普段あまり文章を書かない人間なので考えや意図が正確に伝わる文章かはわからない。おわり。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Vimによる通知センター実装、ThingsPast.vimをリリースしました</title>
    <link rel="alternate" href="http://blog.url.com/articles/vim/thingspast-vim-released.html"/>
    <id>http://blog.url.com/articles/vim/thingspast-vim-released.html</id>
    <published>2013-12-05T15:00:00Z</published>
    <updated>2014-01-24T11:35:37+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://atnd.org/events/45072"&gt;Vim Advent Calendar 2013&lt;/a&gt;、5日目の記事になります。プラグインの完成が遅れ、遅刻力を発揮してしまいました…。&lt;/p&gt;

&lt;h2 id="toc_0"&gt;ThingsPast.vimをリリースしました&lt;/h2&gt;

&lt;p&gt;ThingsPast.vimというプラグインをリリースしました。 これは、Mac OS Xの通知センターのようなものをVim内で実装したものです。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/supermomonga/thingspast.vim"&gt;https://github.com/supermomonga/thingspast.vim&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Macをお持ちでない方のために簡単に説明すると、通知センターは各アプリケーションによるユーザーへの「通知」をハンドリングする機能です。Twitterの新着リプライや新着受信メールなどといった通知の一覧表示や、通知一覧からの選択によってアプリケーションを適切な状態で起動、たとえば通知された新着メールをクリックするとそのメールが選択された状態でメーラーを起動するなど、を行うことができます。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/uploads/2013-12-notifcenter.png" alt="notifcenter" width="314" height="350" class="aligncenter size-full wp-image-978" /&gt;&lt;/p&gt;

&lt;p&gt;ThingsPast.vimは、これをVim内で再実装したものです。&lt;/p&gt;

&lt;h2 id="toc_1"&gt;ThingsPast.vimのメリット&lt;/h2&gt;

&lt;p&gt;Vimで動作するTwitterクライアントやメーラー、Lingrクライアントなど、Vimをプラットフォームとして動作するアプリケーションがあります。これらの新着通知をハンドリングする手段としては、今までGrowlなどのOSレベルの通知アプリケーションと連携して通知を行われるのが一般的でした。&lt;/p&gt;

&lt;p&gt;ですが、この方法には欠点があります。それは、OSから見て、通知元のアプリケーションは単にVimでしかなく、Vimで動作しているどのアプリケーションからの通知であるのかといった情報のハンドリングが難しいことです。&lt;/p&gt;

&lt;p&gt;たとえば、TweetVimというVimで動作するTwitterクライアントがありますが、TweetVimからの「新着リプライ」通知をMac OS Xの通知センターに表示すること自体は可能なものの、それを通知一覧から選択した際にVimを起動し、その中でTweetVimを起動し、該当のリプライや会話を表示する、といった動作を行わせることはかなり難しいのです。&lt;/p&gt;

&lt;p&gt;ThingsPast.vimは、Vim内に独立した通知管理システムを構築することで、こういった問題を解決しました。&lt;/p&gt;

&lt;h2 id="toc_2"&gt;ThingsPast.vimの動作風景&lt;/h2&gt;

&lt;p&gt;&lt;img src="/images/uploads/2013-12-Screen-Shot-2013-12-06-at-01.05.07.png" alt="Screen Shot 2013-12-06 at 01.05.07" width="784" height="560" class="aligncenter size-full wp-image-979" /&gt;&lt;/p&gt;

&lt;p&gt;ThingsPast.vimをインストールし、&lt;code&gt;&amp;lt;Space&amp;gt;n&lt;/code&gt;を打鍵すると、Vimのウィンドウが縦に分割され、右側にプラグインごとの通知一覧が表示されます。&lt;code&gt;j&lt;/code&gt;,&lt;code&gt;k&lt;/code&gt;で通知を選択でき、選択した状態で&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;（Enter）を打鍵すると、プラグインごとに最適な処理が実行され、その後通知一覧から通知は消えます。&lt;/p&gt;

&lt;h2 id="toc_3"&gt;ThingsPast.vimの想定利用シーン&lt;/h2&gt;

&lt;p&gt;ThingsPast.vimの想定している利用シーンとして、以下の様なものがあります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  &lt;a href="https://github.com/basyura/TweetVim"&gt;TweetVim&lt;/a&gt;（Twitterクライアント） 

&lt;ul&gt;
&lt;li&gt;  新着リプライ通知&lt;/li&gt;
&lt;li&gt;  新着DM通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/basyura/J6uil.vim"&gt;J6uil.vim&lt;/a&gt;（Lingrクライアント） 

&lt;ul&gt;
&lt;li&gt;  新着メッセージ通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/yuratomo/gmail.vim"&gt;Gmail.vim&lt;/a&gt;（Gmailクライアント） 

&lt;ul&gt;
&lt;li&gt;  新着メール通知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/Shougo/vimshell.vim"&gt;VimShell.vim&lt;/a&gt;（ターミナルエミュレータ） 

&lt;ul&gt;
&lt;li&gt;  時間がかかった処理が終了した際、VimShellがアクティブバッファでない場合、通知をする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ThingsPast.vimで通知を受け取るには、それぞれのプラグインからThingsPast.vimが提供しているAPI関数をコールする必要があります。ですので、hookの仕組みが実装されているプラグインとの連携を、vimrcの設定で記述することができます。この辺りについて、詳しくはヘルプドキュメントの方をご覧ください。&lt;/p&gt;

&lt;p&gt;実際には、上記のプラグインにはhook機能が不足しておりThingsPast.vimとの連携ができないものが多いのが現状です。&lt;/p&gt;

&lt;p&gt;ThingsPast.vimが一応のリリースに漕ぎ着けましたので、それらプラグインにhook機能を実装しPull Requestを送りたいなと考えています。&lt;/p&gt;

&lt;h2 id="toc_4"&gt;今後の実装予定と課題&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;  設定例の充実化 

&lt;ul&gt;
&lt;li&gt;  そのためにはまず、Hook追加のPull Requestを送りまくることになりそうです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  シンタックスハイライトの実装 

&lt;ul&gt;
&lt;li&gt;  もっと見栄えをかっこよくしたいです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  アニメーションの自走 

&lt;ul&gt;
&lt;li&gt;  選択中の通知は、省略されたメッセージが右から左に流れて全文を読めるようにしたいです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  Hookの実装 

&lt;ul&gt;
&lt;li&gt;  これにより、通知が追加された際に&lt;a href="https://github.com/supermomonga/shaberu.vim"&gt;Shaberu.vim&lt;/a&gt;で音声通知を行う、といったことができるようになります&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  新着通知が追加されたプラグインを上に表示する用に、並び順を改善&lt;/li&gt;
&lt;li&gt;  ステータスラインに通知数を表示することなどができるように、外部からの利用を想定した便利関数の実装&lt;/li&gt;
&lt;li&gt;  コードのリファクタリング 

&lt;ul&gt;
&lt;li&gt;  VimAdventCalendarに間に合わせるために、所々に妥協した面が見えます…&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;  ユニットテストの充実化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;12月7日に開催されるTokyoVimでは、ThingsPast.vimのリファクタリングや機能追加など、重点的に行いたいと思います。&lt;/p&gt;

&lt;h2 id="toc_5"&gt;謝辞&lt;/h2&gt;

&lt;p&gt;ThingsPast.vimは私にとって初めての独自バッファを作成するプラグインであり、Vim scriptプログラミングの経験が浅い私にとって、かなり手探りでの実装となりました。プラグインを作成するにあたってLingrのVim部屋にて多数の方から様々なアドバイスを頂戴し、なんとか完成に至ったという次第です。 アドバイスをくださった皆さまに、この場を借りてお礼申し上げます。&lt;/p&gt;

&lt;h2 id="toc_6"&gt;Vim Advent Calendar 2013 6日目は&lt;/h2&gt;

&lt;p&gt;明日、というか今日ですが、の担当は@kaoriyaさんです。よろしくお願いします！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>今年こそRubyを始めたいあなたに！ももんが流・最強のRuby学習法</title>
    <link rel="alternate" href="http://blog.url.com/articles/ruby/sugoi-learning-way.html"/>
    <id>http://blog.url.com/articles/ruby/sugoi-learning-way.html</id>
    <published>2013-11-30T15:00:00Z</published>
    <updated>2014-01-26T07:56:25+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2 id="toc_0"&gt;Ruby Advent Calendar 2013 1日目&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://qiita.com/advent-calendar/2013/ruby"&gt;Ruby Advent Calendar 2013&lt;/a&gt;、1日目の記事になります。&lt;/p&gt;

&lt;p&gt;こんにちは。1日目の記事ということでかなり緊張しています。&lt;/p&gt;

&lt;p&gt;さて、いつもネタ記事ばかり書いている私ですが、さすがに1日目ということで、入門的な内容、つまり、これからRubyを始めたい方のための記事を書いてみたいと思います。真面目に。&lt;/p&gt;

&lt;p&gt;実は、私もRubyを使い始めてから1年も経っていないのですが、ある学習法を取り入れることで、飛躍的にRuby力を向上させることに成功しました。今回はその方法をお伝えします。&lt;/p&gt;

&lt;div style="height: 400px;"&gt;
&lt;/div&gt;

&lt;h2 id="toc_1"&gt;ステップバイステップ、ももんが流Ruby学習方法&lt;/h2&gt;

&lt;h3 id="toc_2"&gt;ステップ１&lt;/h3&gt;

&lt;div style="font-size: 300%; line-height: 2.0;"&gt;
  まず、&lt;br /&gt;Minecraftを購入します。
&lt;/div&gt;

&lt;p&gt;&lt;img src="/images/uploads/2013-12-Minecraft-logo-1024x373.png" alt="Minecraft-logo" width="1024" height="373" class="full" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://minecraft.net/"&gt;Minecraft&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="toc_3"&gt;ステップ２&lt;/h3&gt;

&lt;p&gt;Minecraftで遊びます。&lt;/p&gt;

&lt;p&gt;&lt;a href="/images/uploads/2013-12-2013-04-06_19.38.55-100e671f.png"&gt;&lt;img src="/images/uploads/2013-12-2013-04-06_19.38.55.png" alt="2013-04-06_19.38.55" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/images/uploads/2013-12-2013-03-31_20.16.13-d0b50402.png"&gt;&lt;img src="/images/uploads/2013-12-2013-03-31_20.16.13.png" alt="2013-03-31_20.16.13" width="854" height="480" class="full" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://blog.aoisensi.info/2013/04/VAC2012-128.html"&gt;images by aoisensi&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="toc_4"&gt;ステップ３&lt;/h3&gt;

&lt;p&gt;「そろそろマルチプレイやるかー」と言ってマルチサーバーを立てて遊びます。&lt;/p&gt;

&lt;p&gt;&lt;a href="/wp-content/uploads/2013-12-tumblr_miolg2ceuM1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_miolg2ceuM1s6y1aoo1_1280.png" alt="tumblr_miolg2ceuM1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/wp-content/uploads/2013-12-tumblr_mipit1mkUU1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_mipit1mkUU1s6y1aoo1_1280.png" alt="tumblr_mipit1mkUU1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/wp-content/uploads/2013-12-tumblr_mirok2luZZ1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_mirok2luZZ1s6y1aoo1_1280.png" alt="tumblr_mirok2luZZ1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/wp-content/uploads/2013-12-tumblr_mirojz6AJQ1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_mirojz6AJQ1s6y1aoo1_1280.png" alt="tumblr_mirojz6AJQ1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/wp-content/uploads/2013-12-tumblr_mirok4G3Ik1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_mirok4G3Ik1s6y1aoo1_1280.png" alt="tumblr_mirok4G3Ik1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;
&lt;a href="/wp-content/uploads/2013-12-tumblr_mirojxWtUQ1s6y1aoo1_1280.png"&gt;&lt;img src="/images/uploads/2013-12-tumblr_mirojxWtUQ1s6y1aoo1_1280.png" alt="tumblr_mirojxWtUQ1s6y1aoo1_1280" width="854" height="480" class="full" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="http://sixeight.supermomonga.com/"&gt;photos by sixeight&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="toc_5"&gt;ステップ４&lt;/h3&gt;

&lt;p&gt;「ほうほう、&lt;a href="http://dl.bukkit.org/downloads/craftbukkit/"&gt;CraftBukkit&lt;/a&gt;という非公式サーバー実装があって、ユーザーが開発したBukkitプラグインを追加することにより色々な機能を追加することができるのかー」と言ってマルチサーバーを公式のものでなくCraftBukkitに移行します。&lt;/p&gt;

&lt;h3 id="toc_6"&gt;ステップ５&lt;/h3&gt;

&lt;p&gt;「MinecraftはJava製なので、オリジナルのBukkitプラグインを作るにはJavaを書く必要があるのかー。&lt;strong&gt;どうせならJRubyで書きたいなぁ&lt;/strong&gt;」と思います。&lt;/p&gt;

&lt;h3 id="toc_7"&gt;ステップ６&lt;/h3&gt;

&lt;p&gt;「おお、&lt;a href="http://dev.bukkit.org/bukkit-plugins/purugin/"&gt;&lt;code&gt;Purugin&lt;/code&gt;というBukkitプラグイン&lt;/a&gt;を使えば、JRubyでBukkitの挙動を拡張できるのか！」と思い、Puruginをインストールします。&lt;/p&gt;

&lt;p&gt;&lt;a href="/wp-content/uploads/2013-12-purugin_logo_big.png"&gt;&lt;img src="/images/uploads/2013-12-purugin_logo_big.png" alt="purugin_logo_big" width="646" height="226" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="toc_8"&gt;ステップ７&lt;/h3&gt;

&lt;p&gt;Minecraftで遊びながらJRubyによるプログラミングを行うことで、Ruby力がメキメキと上昇します。&lt;/p&gt;

&lt;p&gt;また、&lt;strong style="font-size: 120%;"&gt;普通人間は毎日18時間Minecraftをプレイします&lt;/strong&gt;が、これは、Minecraftで遊ぶ時間の1/3をPuruginによる開発に費やすことで、&lt;strong&gt;毎日6時間Rubyの学習を無理なく続けられる&lt;/strong&gt;ことを意味します。&lt;/p&gt;

&lt;h3 id="toc_9"&gt;ステップ８&lt;/h3&gt;

&lt;p&gt;&lt;strong style="font-size: 200%;"&gt;気付いたらRuby力が向上していた&lt;/strong&gt;&lt;/p&gt;

&lt;div style="height: 200px;"&gt;
&lt;/div&gt;

&lt;h2 id="toc_10"&gt;真面目な解説&lt;/h2&gt;

&lt;p&gt;はい、ということですごい真面目にステップバイステップでのRuby学習方法をお伝えしました。嘘です、不真面目でした。&lt;/p&gt;

&lt;p&gt;しかし、上に書いた内容は全くのネタというわけではなく、私が実際にRuby力を向上させた方法でもあります。&lt;/p&gt;

&lt;p&gt;この方法には、プログラミングを学習する上でのすごく大事な要素が詰まっています。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  楽しみながら学べること&lt;/li&gt;
&lt;li&gt;  複数人での開発によって、他の人の良いコード学び、自分の悪いコードを改めることができること&lt;/li&gt;
&lt;li&gt;  ゲームの動作速度に影響を与えないために、非効率的すぎるコードの書き方を改められること&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;プログラマ同士で集まりマルチサーバーの挙動をJRubyで拡張していく、という遊び方をすることで、自然にお互いがコードレビューを行っていく形になりますし、他のプレイヤーが書いた良いコードを読むことでRubyへの理解力が深まります。特に、私にとってのujihisaさんの様な、レベルの高いプログラマと一緒に遊ぶことができれば、その成長は顕著でしょう。&lt;/p&gt;

&lt;p&gt;また、今回は&lt;code&gt;Purugin&lt;/code&gt;というBukkitプラグインをご紹介しましたが、私の場合、私の友人でありプログラミングの師匠でもある&lt;a href="https://twitter.com/ujm/"&gt;ujihisaさん&lt;/a&gt;が開発した&lt;code&gt;mckokoro&lt;/code&gt;という同類のプラグインにてJRubyによるBukkitの拡張を行っていました。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/akechi/mckokoro"&gt;https://github.com/akechi/mckokoro&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mckokoro&lt;/code&gt;が&lt;code&gt;Purugin&lt;/code&gt;より優れている点として、CraftBukkitサーバーの再起動を伴わずに機能の追加などを行える、動的デプロイ機能が挙げられます。これは、githubのwebhookを起点として&lt;code&gt;mckokoro&lt;/code&gt;が&lt;code&gt;sinatra&lt;/code&gt;を用いて用意しているAPIを叩くことで、&lt;code&gt;mckokoro&lt;/code&gt;がgithubから最新のコードを取得し、JRubyコードをそのまま評価することで実現されています。&lt;/p&gt;

&lt;p&gt;これにより、再起動を行わず素早くMinecraftの機能拡張を行っていけるので、特に複数人で遊ぶ際にとても重宝します。&lt;/p&gt;

&lt;p&gt;あなたに&lt;code&gt;mckokoro&lt;/code&gt;でなく&lt;code&gt;Purugin&lt;/code&gt;をご紹介したのは、&lt;code&gt;mckokoro&lt;/code&gt;は配布を前提として作られていないので、コアの実装と&lt;code&gt;mckokoroプラグイン&lt;/code&gt;（JRubyによってBukkitの挙動を拡張する部分）の実装が分離されておらず、全てがひとつのgitリポジトリにまとまってしまっているためです。&lt;/p&gt;

&lt;p&gt;そういった事情から、&lt;code&gt;mckokoro&lt;/code&gt;を導入すると、私やujihisaさんが遊んでいるBukkitサーバーの機能拡張が全て付属してきてしまうのですが、それでも良いので試してみたいという方は私が書いた「&lt;a href="https://github.com/akechi/mckokoro/wiki/LOCAL_SETUP"&gt;CraftBukkitからmckokoroまでの導入手順&lt;/a&gt;」を参考にして頂ければと思います。&lt;/p&gt;

&lt;p&gt;現在、&lt;code&gt;mckokoro&lt;/code&gt;の後続ソフトウェアである&lt;code&gt;neocloft&lt;/code&gt;というBukkitプラグインの開発が進められています。&lt;/p&gt;

&lt;p&gt;&lt;img src="/images/uploads/2013-12-neocloft.png" alt="neocloft" width="474" height="104" /&gt;&lt;/p&gt;

&lt;p&gt;これは、誰でもご自分のBukkitサーバーに導入できるように、&lt;code&gt;neocloftコア&lt;/code&gt;と&lt;code&gt;neocloftアプリ&lt;/code&gt;（JVM言語によってBukkitの挙動を拡張する部分）の実装が疎結合になっています。また、neocloftでは、JRubyだけでなく、コードのeval機構を持った任意のJVM言語、つまりClojureやJythonなどを使って&lt;code&gt;neocloftアプリ&lt;/code&gt;を記述することが可能です。&lt;code&gt;mckokoro&lt;/code&gt;と同じく再起動を伴わない動的デプロイにも対応しているので、ClojureやPythonの勉強をしたい方にも良いのではないでしょうか。neocloftの正式リリース時には、詳細な導入解説記事を書く予定です。&lt;/p&gt;

&lt;h2 id="toc_11"&gt;おわりに&lt;/h2&gt;

&lt;p&gt;いかがでしたでしょうか。この記事があなたがRubyを学習するためのきっかけになれば幸いです。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://qiita.com/advent-calendar/2013/ruby"&gt;Ruby Advent Calendar 2013&lt;/a&gt;、2日目の担当はanoworlさんです。内容は「最高のWeb API開発」との事らしいので、明日は多分真面目な記事が読めるのではないかと思います。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>新・ももんが流NeoBundle管理術（あたらしい）</title>
    <link rel="alternate" href="http://blog.url.com/articles/vim/neobundle-sugoi-setting.html"/>
    <id>http://blog.url.com/articles/vim/neobundle-sugoi-setting.html</id>
    <published>2013-11-25T15:00:00Z</published>
    <updated>2014-01-24T11:35:43+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://atnd.org/events/33746"&gt;Vim Advent Calendar 2012&lt;/a&gt;、361日目の記事になります。&lt;/p&gt;

&lt;p&gt;全世界3000億人の美少女Vimmerのみなさん、こんにちは。&lt;/p&gt;

&lt;p&gt;さて、今回は、おなじみのプラグインマネージャ&lt;a href="https://github.com/Shougo/neobundle.vim"&gt;NeoBundle&lt;/a&gt;に最近追加された&lt;code&gt;neobundle#tap&lt;/code&gt;・&lt;code&gt;neobundle#untap&lt;/code&gt;や、丁度本日追加された&lt;code&gt;autoload&lt;/code&gt;の&lt;code&gt;on_source&lt;/code&gt;オプションを活用した、新・ももんが流NeoBundle管理術をお伝えしていきたいと思います。&lt;/p&gt;

&lt;h2 id="toc_0"&gt;最近追加された&lt;code&gt;neobundle#tap&lt;/code&gt;・&lt;code&gt;neobundle#untap&lt;/code&gt;について&lt;/h2&gt;

&lt;p&gt;これは、私の以前の記事「&lt;a href="/articles/vim/neobundle-sugoibenri.html"&gt;ももんが流NeoBundle管理術&lt;/a&gt;」にてご紹介した&lt;code&gt;s:bundle_tap&lt;/code&gt;関数や&lt;code&gt;s:bundle_untap&lt;/code&gt;関数などを、NeoBundle作者であるShougoさんがオフィシャルな機能として実装してくださったものです。&lt;/p&gt;

&lt;p&gt;NeoBundle付属の関数となったことで若干ですが必要な記述量も減り、よりいい感じになりました。ももんが流NeoBundle管理術のコンセプト・考え方は上記記事を参考にしてください。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;コンセプトは、プラグイン管理とプラグイン設定を分離させる、です。&lt;/p&gt;

&lt;p&gt;具体的には、NeoBundle及びNeoBundleLazyコマンドのオプションは、依存関係やビルドコマンドなどの「プラグインのインストール方法・管理方法」といったものに絞り、autoloadの設定やプラグイン読み込み時の設定は固有のセクションで管理していきます。&lt;/p&gt;

&lt;p&gt;これにより、プラグインリストの見通しがよくなりますし、まぁ色々便利になります。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id="toc_1"&gt;本日追加された&lt;code&gt;autoload&lt;/code&gt;の&lt;code&gt;on_source&lt;/code&gt;オプションについて&lt;/h2&gt;

&lt;p&gt;本日、私が出していた要望が実装されました。それが&lt;code&gt;autoload&lt;/code&gt;の&lt;code&gt;on_source&lt;/code&gt;オプションです。&lt;/p&gt;

&lt;p&gt;NeoBundleがプラグインの遅延ロードに対応していることはご存知かと思います。遅延ロード、つまりLazy化を行ったプラグインには、どういったタイミングでプラグインを読み込むのかを設定する必要があります。それが&lt;code&gt;autoload&lt;/code&gt;オプションになります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;filetype&lt;/code&gt;や&lt;code&gt;commands&lt;/code&gt;などを指定し、それをトリガーにしてプラグインが読み込まれるのですが、本日新たに&lt;code&gt;on_source&lt;/code&gt;というオプションが加わりました。&lt;/p&gt;

&lt;p&gt;これは、&lt;em&gt;&lt;code&gt;on_source&lt;/code&gt;で指定したプラグインが読み込まれようとした際、その前にプラグインをロードする&lt;/em&gt;というオプションになります。&lt;/p&gt;

&lt;p&gt;これによって、特定のプラグインが読み込まれていることを動作の前提としたプラグインの設定の記述がより簡潔に行えるようになります。&lt;/p&gt;

&lt;h2 id="toc_2"&gt;具体例&lt;/h2&gt;

&lt;p&gt;どういうことなのか、あまりピンとこない方が多いかと思います。そこで、具体例を挙げましょう。私のお気に入りの、&lt;a href="https://github.com/Shougo/vimshell.vim"&gt;VimShell&lt;/a&gt;というプラグインがあります。また、VimShellの見た目や機能を拡張するプラグインとして、拙作の&lt;a href="https://github.com/supermomonga/vimshell-pure.vim"&gt;VimShell-Pure&lt;/a&gt;というプラグインがあります。この2つのプラグインの設定を例とします。&lt;/p&gt;

&lt;p&gt;まず、&lt;code&gt;VimShell-Pure&lt;/code&gt;は&lt;code&gt;VimShell&lt;/code&gt;のプロンプトを書き換える機能を搭載しているため、VimShellが起動する前にロード（読み込み）が完了している必要があります。そして、Lazy化された設定において、VimShellが起動するタイミングはVimShellをロードするタイミングとほぼ同じです。つまり、VimShellが&lt;code&gt;:VimShell&lt;/code&gt;コマンドなどの実行によって起動されようとし、そのためにロードが行われる際、そのタイミングで割り込んで&lt;code&gt;VimShell-Pure&lt;/code&gt;を先にロードする必要があります。&lt;/p&gt;

&lt;p&gt;この場合、&lt;code&gt;on_source&lt;/code&gt;オプションを使用せずにそれを実現する設定を記述すると、以下の様になります。&lt;/p&gt;

&lt;pre lang="vim"&gt;" Plugin list
NeoBundleLazy 'Shougo/vimshell.vim', { 'depends' : [ 'Shougo/vimproc.vim' ] }
NeoBundleLazy 'supermomonga/vimshell-pure.vim', { 'depends' : [ 'Shougo/vimshell.vim' ] }

" Plugin settings
if neobundle#tap('vimshell.vim')
  call neobundle#config({
        \   'autoload' : {
        \     'commands' : [ 'VimShell', 'VimShellPop' ]
        \   }
        \ })
  function! neobundle#tapped.hooks.on_source(bundle)
    if neobundle#is_installed('vimshell-pure.vim')
      call neobundle#source('vimshell-pure.vim')
    endif
  endfunction
  call neobundle#untap()
endif

if neobundle#tap('vimshell-pure.vim')
  call neobundle#untap()
endif
&lt;/pre&gt;

&lt;p&gt;注目して欲しいのは&lt;code&gt;neobundle#tapped.hooks.on_source&lt;/code&gt;関数の中身です。これは、そのプラグインがロードされようとした時に呼ばれるhook関数です。その中で、&lt;code&gt;neobundle#is_installed()&lt;/code&gt;関数によって&lt;code&gt;VimShell-Pure&lt;/code&gt;がインストールされているかの確認を行い、インストールされている場合は&lt;code&gt;neobundle#source()&lt;/code&gt;関数によって&lt;code&gt;VimShell-Pure&lt;/code&gt;を読み込むという設定が記述されています。&lt;code&gt;neobundle#tapped.hooks.on_source&lt;/code&gt;の実行が完了、つまり&lt;code&gt;VimShell-Pure&lt;/code&gt;のロードが完了した後、&lt;code&gt;VimShell&lt;/code&gt;がロードされます。&lt;/p&gt;

&lt;p&gt;もちろん、この様に設定を行っても、意図した通りの動作にはなります。しかし、この設定のよくない点は、&lt;code&gt;neobundle#tap&lt;/code&gt;によってスコープ化された&lt;code&gt;VimShell&lt;/code&gt;の設定セクションの中で、&lt;code&gt;VimShell-Pure&lt;/code&gt;の読み込みタイミングに関する設定を行っているという所です。つまり、&lt;code&gt;VimShell-Pure&lt;/code&gt;がいつ・どのようなタイミングで読み込まれるべきなのかといった「VimShell-Pureのふるまい」を、「VimShellのふるまいを定義するべきセクション」の中で定義してしまっているのです。&lt;/p&gt;

&lt;p&gt;せっかく&lt;code&gt;neobundle#tap&lt;/code&gt;を用いることでプラグインの設定セクションが明確化されたのに、複数のプラグインのふるまいに関する設定が１つのセクション内に混在している状況は精神衛生上よろしくありません。また、&lt;code&gt;VimShell-Pure&lt;/code&gt;のふるまいを決める設定、特に読み込みに関するものが&lt;code&gt;VimShell&lt;/code&gt;の設定セクション内に残っていると、たとえば&lt;code&gt;VimShell-Pure&lt;/code&gt;プラグインの使用を一時的に中止たいと思い、&lt;code&gt;VimShell-Pure&lt;/code&gt;プラグインの設定セクション（tapからuntapまで）をコメントアウトした場合も、&lt;code&gt;VimShell&lt;/code&gt;の設定セクション内に&lt;code&gt;VimShell-Pure&lt;/code&gt;の読み込み設定が残っており、意図せずプラグインが読み込まれてしまうといった弊害も考えられます。&lt;/p&gt;

&lt;p&gt;それに対して、&lt;code&gt;on_source&lt;/code&gt;オプションを利用した設定は以下の通りになります。&lt;/p&gt;

&lt;pre lang="vim"&gt;" Plugin list
NeoBundleLazy 'Shougo/vimshell.vim', { 'depends' : [ 'Shougo/vimproc.vim' ] }
NeoBundleLazy 'supermomonga/vimshell-pure.vim', { 'depends' : [ 'Shougo/vimshell.vim' ] }

" Plugin settings
if neobundle#tap('vimshell.vim')
  call neobundle#config({
        \   'autoload' : {
        \     'commands' : [ 'VimShell', 'VimShellPop' ]
        \   }
        \ })
  call neobundle#untap()
endif

if neobundle#tap('vimshell-pure.vim')
  call neobundle#config({
        \   'autoload' : {
        \     'on_source' : [ 'vimshell.vim' ]
        \   }
        \ })
  call neobundle#untap()
endif
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;VimShell-Pure&lt;/code&gt;がいつ・どのようなタイミングで読み込まれるべきなのかといった「VimShell-Pureのふるまい」が、ちゃんと「VimShell-Pureのふるまいを定義するべきセクション」の中で完結して定義されていることがお分かりでしょうか。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;neobundle#tap&lt;/code&gt;と&lt;code&gt;neobundle#untap&lt;/code&gt;を使用しそれぞれのプラグインの設定をそれぞれのセクション内に閉じ込めるということで、どのプラグインの設定がどこに記述されているのかといった情報が明確になりvimrc管理がとても行い易くなります。&lt;code&gt;autoload&lt;/code&gt;の&lt;code&gt;on_source&lt;/code&gt;オプションを利用することで、読み込み順に関してもそれが行えるようになり、より見通しのよい&lt;code&gt;.vimrc&lt;/code&gt;を作れるようになりました。&lt;/p&gt;

&lt;h2 id="toc_3"&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;  「プラグインのインストール管理」と「プラグインのふるまい方の設定」の記述を分離させよう&lt;/li&gt;
&lt;li&gt;  それぞれのプラグインのふるまいを決める設定は、&lt;code&gt;neobundle#tap&lt;/code&gt;・&lt;code&gt;neobundle#untap&lt;/code&gt;で作ったそれぞれのセクション内に閉じ込め、混在しないようにしよう&lt;/li&gt;
&lt;li&gt;  プラグインの読み込みタイミング制御は、新しく実装された&lt;code&gt;autoload&lt;/code&gt;の&lt;code&gt;on_source&lt;/code&gt;オプションによりセクジョン内で記述できるようになった&lt;/li&gt;
&lt;li&gt;  「新・ももんが流NeoBundle管理術」という割には、NeoBundleの標準機能しか使っていない&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="toc_4"&gt;Vim Advent Calendar 2012 362日目は&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://atnd.org/events/33746"&gt;Vim Advent Calendar 2012&lt;/a&gt; 362日目の担当は@thincaさんです。&lt;/p&gt;

&lt;p&gt;いよいよ、365日制覇目前です。恐らくこの記事がVim Advent Calendar 2012における私の最後の記事になるでしょう。とても感慨深く思います。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>neosnippetとsmartinputで&amp;lt;CR&amp;gt;キーのマッピングを共存させる</title>
    <link rel="alternate" href="http://blog.url.com/articles/vim/share-cr-map-with-multiple-plugins.html"/>
    <id>http://blog.url.com/articles/vim/share-cr-map-with-multiple-plugins.html</id>
    <published>2013-11-19T15:00:00Z</published>
    <updated>2014-01-24T11:35:43+09:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://atnd.org/events/33746"&gt;Vim Advent Calendar 2012&lt;/a&gt;、355日目の記事になります。&lt;/p&gt;

&lt;h2 id="toc_0"&gt;&lt;code&gt;&amp;lt;cr&amp;gt;&lt;/code&gt;のマッピングについて&lt;/h2&gt;

&lt;p&gt;本日は、&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;のマッピングを複数のプラグイン間で共有する設定について記事にしたいと思います。&lt;/p&gt;

&lt;p&gt;例として、&lt;a href="https://github.com/Shougo/neosnippet.vim"&gt;neosnippet&lt;/a&gt;及び&lt;a href="https://github.com/Shougo/neocomplete.vim"&gt;neocomplete&lt;/a&gt;と&lt;a href="https://github.com/kana/vim-smartinput/"&gt;smartinput&lt;/a&gt;及び&lt;a href="https://github.com/cohama/vim-smartinput-endwise/"&gt;smartinput-endwise&lt;/a&gt;の設定を共存させる方法をお伝えします。&lt;/p&gt;

&lt;h2 id="toc_1"&gt;行いたい動作&lt;/h2&gt;

&lt;p&gt;まず、私は&lt;code&gt;neocomplete&lt;/code&gt;で&lt;code&gt;neosnippet&lt;/code&gt;の候補を補完し、さらに候補にフォーカスが当たっている状態で&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;を押下することにより、スニペットを展開したいと考えています。&lt;/p&gt;

&lt;p&gt;更に、補完ポップアップメニューが表示されていない状態で&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;を押下した際には、&lt;code&gt;smartinput-endwise&lt;/code&gt;により、関数定義の閉じendなどを文脈から判断じて自動挿入したいと思います。&lt;/p&gt;

&lt;h2 id="toc_2"&gt;設定&lt;/h2&gt;

&lt;p&gt;前提として、以下のプラグインを&lt;a href="https://github.com/Shougo/neobundle.vim"&gt;neobundle&lt;/a&gt;で管理しているものとします。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  &lt;a href="https://github.com/Shougo/neocomplete.vim"&gt;neocomplete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/Shougo/neosnippet.vim"&gt;neosnippet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/kana/vim-smartinput/"&gt;smartinput&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  &lt;a href="https://github.com/cohama/vim-smartinput-endwise/"&gt;smartinput-endwise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang="vim"&gt;if neobundle#tap('vim-smartinput')
  call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1
        \   }
        \ })

  function! neobundle#tapped.hooks.on_post_source(bundle)
    call smartinput_endwise#define_default_rules()
  endfunction

  call neobundle#untap()
endif

if neobundle#tap('vim-smartinput-endwise')
  function! neobundle#tapped.hooks.on_post_source(bundle)
    " neosnippet and neocomplete compatible
    call smartinput#map_to_trigger('i', '&amp;lt;Plug&gt;(vimrc_cr)', '&amp;lt;Enter&gt;', '&amp;lt;Enter&gt;')
    imap &amp;lt;expr&gt;&amp;lt;CR&gt; !pumvisible() ? "\&amp;lt;Plug&gt;(vimrc_cr)" :
          \ neosnippet#expandable() ? "\&amp;lt;Plug&gt;(neosnippet_expand)" :
          \ neocomplete#close_popup()
  endfunction
  call neobundle#untap()
endif

&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;smartinput_endwise#define_default_rules()&lt;/code&gt;を実行した時点で、&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;のマップが&lt;code&gt;smartinput&lt;/code&gt;によって上書きされてしまいます。ですので、&lt;code&gt;neobundle#tapped.hooks.on_post_source(bundle)&lt;/code&gt;によって、その後に再度&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;をオリジナルの設定でマッピングします。&lt;/p&gt;

&lt;pre lang="vim"&gt;call smartinput#map_to_trigger('i', '&amp;lt;Plug&gt;(vimrc_cr)', '&amp;lt;Enter&gt;', '&amp;lt;Enter&gt;')
imap &amp;lt;expr&gt;&amp;lt;CR&gt; !pumvisible() ? "\&amp;lt;Plug&gt;(vimrc_cr)" :
      \ neosnippet#expandable() ? "\&amp;lt;Plug&gt;(neosnippet_expand)" :
      \ neocomplete#close_popup()
&lt;/pre&gt;

&lt;p&gt;こちらについて解説します。 まず、&lt;code&gt;smartinput#map_to_trigger&lt;/code&gt;によって、&lt;code&gt;&amp;lt;Plug&amp;gt;(vimrc_cr)&lt;/code&gt;が押下された時に&lt;code&gt;smartinput-endwise&lt;/code&gt;が動作するように設定します。 次に&lt;code&gt;imap&lt;/code&gt;によって&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;のマッピングを上書きします。&lt;code&gt;imap &amp;lt;expr&amp;gt;&amp;lt;CR&amp;gt;&lt;/code&gt;といった様に、&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;を使うことでマップ内容に式を書くことができます。&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;が押下されるたびに設定した式が評価されます。&lt;/p&gt;

&lt;p&gt;式の内容を見て行きましょう。まず、&lt;code&gt;!pumvisible()&lt;/code&gt;は&lt;code&gt;pumvisible()&lt;/code&gt;が偽である時、つまり補完ポップアップメニューが開いていない時を意味します。補完を行っていない時は&lt;code&gt;smartinput&lt;/code&gt;に処理を渡したいので、先ほど設定した&lt;code&gt;&amp;lt;Plug&amp;gt;(vimrc_cr)&lt;/code&gt;を呼び出しています。次に&lt;code&gt;pumvisible()&lt;/code&gt;が真である場合ですが、ここで三項演算子がネストしています。こちらは、&lt;code&gt;neosnippet#expandable()&lt;/code&gt;が真（現在選択されている補完候補が&lt;code&gt;neosnippet&lt;/code&gt;のものであり、スニペットが展開できる状態）であればスニペットを展開し、そうでなければ補完ポップアップメニューを閉じるという式になっています。&lt;/p&gt;

&lt;p&gt;これにより、&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;を押下した時の動作を、以下のように定義することができました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  分岐1：補完ポップアップメニューが表示されていれば分岐2へ、そうでなければ&lt;code&gt;smartinput&lt;/code&gt;にて&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt;を押下時に呼び出される関数を呼び出す&lt;/li&gt;
&lt;li&gt;  分岐2：スニペット候補が展開されていればスニペットを展開し、そうでなければ補完ポップアップメニューを閉じる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="toc_3"&gt;まとめ&lt;/h2&gt;

&lt;p&gt;かなりべんり（かなり）&lt;/p&gt;
</content>
  </entry>
</feed>
